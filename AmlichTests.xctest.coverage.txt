/Volumes/WIP/Amlich/Sources/Amlich/Amlich.swift:
    1|       |//
    2|       |//  Amlich.swift
    3|       |//
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/18/20.
    6|       |//
    7|       |//  This is the implementation in Swift of the original JS version
    8|       |//  https://github.com/vanng822/amlich/blob/master/lib/amlich-aa98.js
    9|       |//
   10|       |
   11|       |import Foundation
   12|       |
   13|       |public struct Amlich {
   14|       |    /*
   15|       |     * Compute the (integral) Julian day number of day dd/mm/yyyy, i.e., the number
   16|       |     * of days between 1/1/4713 BC (Julian calendar) and dd/mm/yyyy.
   17|       |     * Formula from http://www.tondering.dk/claus/calendar.html
   18|       |     */
   19|     26|    static func fromDate(_ date: SolarDate) -> Int {
   20|     26|        let (day, month, year) = (date.day, date.month, date.year)
   21|     26|
   22|     26|        let a: Double = floor(Double(14 - month) / 12.0)
   23|     26|        let y: Double = Double(year) + 4800.0 - a
   24|     26|        let m: Double = Double(month) + 12.0 * a - 3.0
   25|     26|
   26|     26|        var jd: Double = Double(day) + floor((153.0 * m + 2.0) / 5.0) + 365.0 * y + floor(y / 4.0) - floor(y / 100.0) + floor(y / 400.0) - 32045.0
   27|     26|
   28|     26|        if jd < 2299161.0 {
   29|      1|            jd = Double(day) + floor((153.0 * m + 2.0) / 5.0) + 365.0 * y + floor(y / 4.0) - 32083.0
   30|     26|        }
   31|     26|
   32|     26|        return Int(jd)
   33|     26|    }
   34|       |
   35|       |
   36|       |    /*
   37|       |     * Convert a Julian day number to day/month/year.
   38|       |     */
   39|      5|    static func toDate(jd: Int) -> SolarDate {
   40|      5|        var a, b, c: Int
   41|      5|
   42|      5|        if jd > 2299160 { // After 5/10/1582, Gregorian calendar
   43|      4|            a = jd + 32044
   44|      4|            b = (4 * a + 3) / 146097
   45|      4|            c = a - (b * 146097) / 4
   46|      5|        } else {
   47|      1|            b = 0
   48|      1|            c = jd + 32082
   49|      5|        }
   50|      5|
   51|      5|        let d = (4 * c + 3) / 1461
   52|      5|        let e = c - (1461 * d) / 4
   53|      5|        let m = (5 * e + 2) / 153
   54|      5|        let day = e - (153 * m + 2) / 5 + 1
   55|      5|        let month = m + 3 - 12 * (m / 10)
   56|      5|        let year = b * 100 + d - 4800 + m / 10
   57|      5|
   58|      5|        return SolarDate(day: day, month: month, year: year)
   59|      5|    }
   60|       |
   61|       |
   62|       |    /*
   63|       |     * Compute the time of the k-th new moon after the new moon of 1/1/1900 13:52 UCT
   64|       |     * (measured as the number of days since 1/1/4713 BC noon UCT, e.g., 2451545.125 is 1/1/2000 15:00 UTC).
   65|       |     * Returns a floating number, e.g., 2415079.9758617813 for k=2 or 2414961.935157746 for k=-2
   66|       |     * Algorithm from: "Astronomical Algorithms" by Jean Meeus, 1998
   67|       |     */
   68|    120|    static func newMoon(of k: Int) -> Double {
   69|    120|        let T: Double = Double(k) / 1236.85 // Time in Julian centuries from 1900 January 0.5
   70|    120|        let T2: Double = T * T
   71|    120|        let T3: Double = T2 * T
   72|    120|        let dr: Double = Double.pi / 180
   73|    120|
   74|    120|        var Jd1: Double = 2415020.75933 + 29.53058868 * Double(k) + 0.0001178 * T2 - 0.000000155 * T3
   75|    120|        Jd1 = Jd1 + 0.00033 * sin((166.56 + 132.87 * T - 0.009173 * T2) * dr)       // Mean new moon
   76|    120|
   77|    120|        let M: Double = 359.2242 + 29.10535608 * Double(k) - 0.0000333 * T2 - 0.00000347 * T3           // Sun's mean anomaly
   78|    120|        let Mpr: Double = 306.0253 + 385.81691806 * Double(k) + 0.0107306 * T2 + 0.00001236 * T3        // Moon's mean anomaly
   79|    120|        let F: Double = 21.2964 + 390.67050646 * Double(k) - 0.0016528 * T2 - 0.00000239 * T3           // Moon's argument of latitude
   80|    120|        var C1: Double = (0.1734 - 0.000393 * T) * sin(M * dr) + 0.0021 * sin(2 * dr * M)
   81|    120|        C1 = C1 - 0.4068 * sin(Mpr * dr) + 0.0161 * sin(dr * 2 * Mpr)
   82|    120|        C1 = C1 - 0.0004 * sin(dr * 3 * Mpr)
   83|    120|        C1 = C1 + 0.0104 * sin(dr * 2 * F) - 0.0051 * sin(dr * (M + Mpr))
   84|    120|        C1 = C1 - 0.0074 * sin(dr * (M - Mpr)) + 0.0004 * sin(dr * (2 * F + M))
   85|    120|        C1 = C1 - 0.0004 * sin(dr * (2 * F - M)) - 0.0006 * sin(dr * (2 * F + Mpr))
   86|    120|        C1 = C1 + 0.0010 * sin(dr * (2 * F - Mpr)) + 0.0005 * sin(dr * (2 * Mpr + M))
   87|    120|
   88|    120|        var deltat: Double
   89|    120|        if T < -11 {
   90|     11|            deltat = 0.001 + 0.000839 * T + 0.0002261 * T2 - 0.00000845 * T3 - 0.000000081 * T * T3
   91|    120|        } else {
   92|    109|            deltat = -0.000278 + 0.000265*T + 0.000262 * T2
   93|    120|        }
   94|    120|
   95|    120|        let JdNew: Double = Jd1 + C1 - deltat
   96|    120|
   97|    120|        return JdNew
   98|    120|    }
   99|       |
  100|       |
  101|       |    /*
  102|       |     * Compute the longitude of the sun at any time.
  103|       |     * Parameter: floating number jdn, the number of days since 1/1/4713 BC noon
  104|       |     * Algorithm from: "Astronomical Algorithms" by Jean Meeus, 1998
  105|       |     */
  106|     97|    static func sunLongitude(of jdn: Double) -> Double {
  107|     97|        let T: Double = (jdn - 2451545.0 ) / 36525 // Time in Julian centuries from 2000-01-01 12:00:00 GMT
  108|     97|        let T2: Double = T * T
  109|     97|        let dr: Double = Double.pi / 180 // degree to radian
  110|     97|        let M: Double = 357.52910 + 35999.05030 * T - 0.0001559 * T2 - 0.00000048 * T * T2 // mean anomaly, degree
  111|     97|        let L0: Double = 280.46645 + 36000.76983 * T + 0.0003032 * T2 // mean longitude, degree
  112|     97|        var DL: Double = (1.914600 - 0.004817 * T - 0.000014 * T2) * sin(dr * M)
  113|     97|        DL = DL + (0.019993 - 0.000101 * T) * sin(dr * 2 * M) + 0.000290 * sin(dr * 3 * M)
  114|     97|
  115|     97|        var L: Double = L0 + DL // true longitude, degree
  116|     97|        L = L * dr
  117|     97|        L = L - Double.pi * 2 * Double(Int(floor(L / (Double.pi * 2)))) // Normalize to (0, 2*PI)
  118|     97|        return L
  119|     97|    }
  120|       |
  121|       |    /*
  122|       |     * Compute the longitude of the sun at any time.
  123|       |     * Parameter: floating number jdn, the number of days since 1/1/4713 BC noon
  124|       |     * Return a number in range (0, 360)
  125|       |     */
  126|      2|    static func sunLongitudeAsAngle(of jdn: Double) -> Double {
  127|      2|        let T: Double = (jdn - 2451545.0 ) / 36525 // Time in Julian centuries from 2000-01-01 12:00:00 GMT
  128|      2|        let T2: Double = T * T
  129|      2|        let dr: Double = Double.pi / 180 // degree to radian
  130|      2|        let M: Double = 357.52910 + 35999.05030 * T - 0.0001559 * T2 - 0.00000048 * T * T2 // mean anomaly, degree
  131|      2|        let L0: Double = 280.46645 + 36000.76983 * T + 0.0003032 * T2 // mean longitude, degree
  132|      2|        var DL: Double = (1.914600 - 0.004817 * T - 0.000014 * T2) * sin(dr * M)
  133|      2|        DL = DL + (0.019993 - 0.000101 * T) * sin(dr * 2 * M) + 0.000290 * sin(dr * 3 * M)
  134|      2|
  135|      2|        let omega: Double = 125.04 - 1934.136 * T
  136|      2|        var L: Double = L0 + DL // true longitude, degree
  137|      2|        L = L - 0.00569 - 0.00478 * sin(omega * dr)
  138|      2|        L = L - 360.0 * Double(Int(floor(L / 360.0))) // Normalize to (0, 2*PI)
  139|      2|        return L
  140|      2|    }
  141|       |
  142|       |
  143|       |    /*
  144|       |     * Compute sun position at midnight of the day with the given Julian day number.
  145|       |     * The time zone if the time difference between local time and UTC: 7.0 for UTC+7:00.
  146|       |     * The function returns a number between 0 and 11.
  147|       |     * From the day after March equinox and the 1st major term after March equinox, 0 is returned.
  148|       |     * After that, return 1, 2, 3 ...
  149|       |     */
  150|     96|    static func sunLongitude(of dayNumber: Int, with timeZone: Double) -> Int {
  151|     96|        return Int(floor(self.sunLongitude(of: Double(dayNumber) - 0.5 - timeZone / 24.0) / Double.pi * 6.0))
  152|     96|    }
  153|       |
  154|       |    
  155|       |    /*
  156|       |     * Compute the day of the k-th new moon in the given time zone.
  157|       |     * The time zone if the time difference between local time and UTC: 7.0 for UTC+7:00
  158|       |     */
  159|    119|    static func newMoonDay(of k: Int, with timeZone: Double) -> Int {
  160|    119|        return Int(floor(self.newMoon(of: k) + 0.5 + timeZone / 24.0))
  161|    119|    }
  162|       |
  163|       |
  164|       |    /*
  165|       |     * Find the day that starts the luner month 11 of the given year for the given time zone
  166|       |     */
  167|     19|    static func lunarMonth11(of year: Int, with timeZone: Double) -> Int {
  168|     19|        let off: Double = Double(self.fromDate(SolarDate(day: 31, month: 12, year: year))) - 2415021
  169|     19|        let k: Int = Int(floor(Double(off) / 29.530588853))
  170|     19|        var nm: Int = newMoonDay(of: k, with: timeZone)
  171|     19|        let sunLong: Int = self.sunLongitude(of: nm, with: timeZone)
  172|     19|
  173|     19|        if sunLong >= 9 {
  174|      9|            nm = self.newMoonDay(of: k - 1, with: timeZone)
  175|     19|        }
  176|     19|
  177|     19|        return nm
  178|     19|    }
  179|       |
  180|       |
  181|       |    /*
  182|       |     * Find the index of the leap month after the month starting on the day a11.
  183|       |     */
  184|     10|    static func leapMonthOffset(of day: Int, with timeZone: Double) -> Int {
  185|     10|        let k: Int = Int(floor(0.5 + (Double(day) - 2415021.076998695) / 29.530588853))
  186|     10|
  187|     10|        var last: Int
  188|     10|        var i = 1
  189|     10|        var arc: Int = self.sunLongitude(of: self.newMoonDay(of: k + i, with: timeZone), with: timeZone)
  190|     10|
  191|     66|        repeat {
  192|     66|            last = arc
  193|     66|            i += 1
  194|     66|            arc = self.sunLongitude(of: self.newMoonDay(of: k + i, with: timeZone), with: timeZone)
  195|     66|        } while arc != last && i < 14
  196|     10|
  197|     10|        return i - 1
  198|     10|    }
  199|       |
  200|       |
  201|       |    /*
  202|       |     * Conver solar day dd/mm/yyyy to the corersponding lunar day
  203|       |     */
  204|      5|    public static func toLunar(of solarDate: SolarDate, with timeZone: Double = 0) -> LunarDate {
  205|      5|        var lunarDay, lunarMonth, lunarYear: Int
  206|      5|        var isLeap: Bool = false
  207|      5|
  208|      5|        let dayNumber: Int = self.fromDate(solarDate)
  209|      5|        let k: Int = Int(floor((Double(dayNumber) - 2415021.076998695) / 29.530588853))
  210|      5|
  211|      5|        var monthStart = newMoonDay(of: k + 1, with: timeZone)
  212|      5|
  213|      5|        if monthStart > dayNumber {
  214|      5|            monthStart = newMoonDay(of: k, with: timeZone)
  215|      5|        }
  216|      5|
  217|      5|        var a11 = lunarMonth11(of: solarDate.year, with: timeZone)
  218|      5|        var b11 = a11
  219|      5|
  220|      5|        if a11 >= monthStart {
  221|      5|            lunarYear = solarDate.year
  222|      5|            a11 = lunarMonth11(of: solarDate.year - 1, with: timeZone)
  223|      5|        } else {
  224|      0|            lunarYear = solarDate.year + 1
  225|      0|            b11 = lunarMonth11(of: solarDate.year + 1, with: timeZone)
  226|      5|        }
  227|      5|
  228|      5|        lunarDay = dayNumber - monthStart + 1
  229|      5|
  230|      5|        let diff: Int = Int(floor(Double(monthStart - a11) / 29.0))
  231|      5|        lunarMonth = diff + 11
  232|      5|
  233|      5|        if b11 - a11 > 365 {
  234|      5|            let leapMonthDiff = leapMonthOffset(of: a11, with: timeZone)
  235|      5|            if diff >= leapMonthDiff {
  236|      5|                lunarMonth = diff + 10
  237|      5|                if diff == leapMonthDiff {
  238|      1|                    isLeap = true
  239|      5|                }
  240|      5|            }
  241|      5|        }
  242|      5|
  243|      5|        if lunarMonth > 12 {
  244|      5|            lunarMonth -= 12
  245|      5|        }
  246|      5|        if lunarMonth >= 11 && diff < 4 {
  247|      0|            lunarYear -= 1
  248|      5|        }
  249|      5|
  250|      5|        return LunarDate(day: lunarDay, month: lunarMonth, year: lunarYear, isLeap: isLeap)
  251|      5|    }
  252|       |
  253|       |    
  254|       |    /*
  255|       |     * Convert a lunar date to the corresponding solar date
  256|       |     */
  257|      4|    public static func toSolar(of lunar: LunarDate, with timeZone: Double = 0) -> SolarDate {
  258|      4|        var a11, b11: Int
  259|      4|
  260|      4|        if (lunar.month < 11) {
  261|      4|            a11 = lunarMonth11(of: lunar.year - 1, with: timeZone)
  262|      4|            b11 = lunarMonth11(of: lunar.year, with: timeZone)
  263|      4|        } else {
  264|      0|            a11 = lunarMonth11(of: lunar.year, with: timeZone)
  265|      0|            b11 = lunarMonth11(of: lunar.year + 1, with: timeZone)
  266|      4|        }
  267|      4|
  268|      4|        let k: Int = Int(floor(0.5 + (Double(a11) - 2415021.076998695) / 29.530588853))
  269|      4|        var off: Int = lunar.month - 11
  270|      4|
  271|      4|        if off < 0 {
  272|      4|            off += 12
  273|      4|        }
  274|      4|
  275|      4|        if b11 - a11 > 365 {
  276|      4|            let leapOff: Int = leapMonthOffset(of: a11, with: timeZone)
  277|      4|            var leapMonth: Int = leapOff - 2
  278|      4|            if leapMonth < 0 {
  279|      0|                leapMonth += 12
  280|      4|            }
  281|      4|            if lunar.isLeap && lunar.month != leapMonth {
  282|      0|                return SolarDate(day: 0, month: 0, year: 0)
  283|      4|            } else if lunar.isLeap || off >= leapOff {
  284|      4|                off += 1
  285|      4|            }
  286|      4|        }
  287|      4|
  288|      4|        let monthStart = newMoonDay(of: k + off, with: timeZone)
  289|      4|
  290|      4|        return self.toDate(jd: monthStart + lunar.day - 1)
  291|      4|    }
  292|       |}

/Volumes/WIP/Amlich/Sources/Amlich/LunarDate.swift:
    1|       |//
    2|       |//  LunarDate.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/18/20.
    6|       |//
    7|       |import Foundation
    8|       |
    9|       |public struct LunarDate: Equatable, Comparable {
   10|       |    public let day: Int
   11|       |    public let month: Int
   12|       |    public let year: Int
   13|       |    public let isLeap: Bool
   14|       |
   15|     18|    public init(day: Int, month: Int, year: Int, isLeap: Bool) {
   16|     18|        self.day = day
   17|     18|        self.month = month
   18|     18|        self.year = year
   19|     18|        self.isLeap = isLeap
   20|     18|    }
   21|       |
   22|      8|    public static func < (lhs: LunarDate, rhs: LunarDate) -> Bool {
   23|      8|        if lhs.year < rhs.year || lhs.month < rhs.month || lhs.day < rhs.day {
   24|      2|            return true
   25|      6|        }
   26|      6|
   27|      6|        return false
   28|      8|    }
   29|       |}
   30|       |
   31|       |extension LunarDate {
   32|      1|    public func toSolar(with timeZone: Double = 0) -> SolarDate {
   33|      1|        return Amlich.toSolar(of: self, with: timeZone)
   34|      1|    }
   35|       |
   36|      2|    public func toDate() -> Date? {
   37|      2|        let dateFormatter = DateFormatter()
   38|      2|        dateFormatter.dateFormat = "dd MM yyyy"
   39|      2|
   40|      2|        return dateFormatter.date(from: "\(self.day) \(self.month) \(self.year)")
   41|      2|    }
   42|       |    
   43|      1|    public static func of(solar date: SolarDate, with timeZone: Double = 0) -> LunarDate {
   44|      1|        return Amlich.toLunar(of: date, with: timeZone)
   45|      1|    }
   46|       |
   47|      1|    public static func of(_ date: Date, with timeZone: Double = 0) -> LunarDate {
   48|      1|        return Amlich.toLunar(of: SolarDate.from(date), with: timeZone)
   49|      1|    }
   50|       |
   51|      2|    public static func from(_ date: Date) -> LunarDate {
   52|      2|        let components = Calendar.current.dateComponents([.day, .month, .year], from: date)
   53|      2|
   54|      2|        // TODO: calculate isLeap
   55|      2|        return LunarDate(day: components.day ?? 0, month: components.month ?? 0, year: components.year ?? 0, isLeap: false)
   56|      2|    }
   57|       |}
   58|       |
   59|       |extension LunarDate: CustomStringConvertible {
   60|      0|    public var description: String {
   61|      0|        return "Lunar Date: day: \(day), month: \(month), year: \(year), isLeep: \(isLeap)"
   62|      0|    }
   63|       |}

/Volumes/WIP/Amlich/Sources/Amlich/SolarDate.swift:
    1|       |//
    2|       |//  SolarDate.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/18/20.
    6|       |//
    7|       |import Foundation
    8|       |
    9|       |public struct SolarDate: Equatable, Comparable {
   10|       |    public let day: Int
   11|       |    public let month: Int
   12|       |    public let year: Int
   13|       |
   14|     38|    public init(day: Int, month: Int, year: Int) {
   15|     38|        self.day = day
   16|     38|        self.month = month
   17|     38|        self.year = year
   18|     38|    }
   19|       |
   20|      8|    public static func < (lhs: SolarDate, rhs: SolarDate) -> Bool {
   21|      8|        if lhs.year < rhs.year || lhs.month < rhs.month || lhs.day < rhs.day {
   22|      2|            return true
   23|      6|        }
   24|      6|
   25|      6|        return false
   26|      8|    }
   27|       |}
   28|       |
   29|       |extension SolarDate {
   30|      1|    public func toLunar(with timeZone: Double = 0) -> LunarDate {
   31|      1|        return Amlich.toLunar(of: self, with: timeZone)
   32|      1|    }
   33|       |
   34|      2|    public func toDate() -> Date? {
   35|      2|        let dateFormatter = DateFormatter()
   36|      2|        dateFormatter.dateFormat = "dd MM yyyy"
   37|      2|
   38|      2|        return dateFormatter.date(from: "\(self.day) \(self.month) \(self.year)")
   39|      2|    }
   40|       |    
   41|      1|    public static func of(lunar date: LunarDate, with timeZone: Double = 0) -> SolarDate {
   42|      1|        return Amlich.toSolar(of: date, with: timeZone)
   43|      1|    }
   44|       |
   45|      1|    public static func of(_ date: Date, with timeZone: Double = 0) -> SolarDate {
   46|      1|        return Amlich.toSolar(of: LunarDate.from(date), with: timeZone)
   47|      1|    }
   48|       |
   49|       |
   50|      2|    public static func from(_ date: Date) -> SolarDate {
   51|      2|        let components = Calendar.current.dateComponents([.day, .month, .year], from: date)
   52|      2|
   53|      2|        return SolarDate(day: components.day ?? 0, month: components.month ?? 0, year: components.year ?? 0)
   54|      2|    }
   55|       |}
   56|       |
   57|       |extension SolarDate: CustomStringConvertible {
   58|      0|    public var description: String {
   59|      0|        return "Solar Date: day: \(day), month: \(month), year: \(year)"
   60|      0|    }
   61|       |}

/Volumes/WIP/Amlich/Sources/Amlich/SolarTerm.swift:
    1|       |//
    2|       |//  SolarTerm.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/19/20.
    6|       |//
    7|       |import Foundation
    8|       |
    9|       |public enum SolarTerm: Int, CaseIterable {
   10|       |    case startOfSpring = 1
   11|       |    case rainWater
   12|       |    case awakeningOfInsects
   13|       |    case vernalEquinox
   14|       |    case clearAndBright
   15|       |    case grainRain
   16|       |    case startOfSummer
   17|       |    case grainFull
   18|       |    case grainInEar
   19|       |    case summerSolstice
   20|       |    case minorHeat
   21|       |    case majorHeat
   22|       |    case startOfAutumn
   23|       |    case limitOfHeat
   24|       |    case whiteDew
   25|       |    case autumnalEquinox
   26|       |    case coldDew
   27|       |    case frostDescent
   28|       |    case startOfWinter
   29|       |    case minorSnow
   30|       |    case majorSnow
   31|       |    case winterSolstice
   32|       |    case minorCold
   33|       |    case majorCold
   34|       |
   35|      1|    public static func of(solar date: SolarDate, in hour: (hh: Int, mm: Int), with timeZone: Double) -> SolarTerm {
   36|      1|        let (hh, mm) = hour
   37|      1|        let jdn = Amlich.fromDate(date)
   38|      1|        let jdnWithHour: Double = Double(jdn) + Double(hh - 12)/24.0 + Double(mm)/1440.0 - timeZone / 24.0
   39|      1|        let sunLongitudeAtJDN = Amlich.sunLongitudeAsAngle(of: jdnWithHour)
   40|      1|
   41|      1|        let index = Int(round(sunLongitudeAtJDN / 15))
   42|      1|        return SolarTerm.allCases[index - 1]
   43|      1|    }
   44|       |}

/Volumes/WIP/Amlich/Tests/AmlichTests/AmlichTestCase.swift:
    1|       |//
    2|       |//  LunarDate.swift
    3|       |//
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/18/20.
    6|       |//
    7|       |
    8|       |
    9|       |import XCTest
   10|       |@testable import Amlich
   11|       |
   12|       |final class AmlichTestCase: XCTestCase {
   13|      1|    func test_fromDate() {
   14|      1|        let date = SolarDate(day: 4, month: 10, year: 1582)
   15|      1|        XCTAssertEqual(Amlich.fromDate(date), 2299160)
   16|      1|    }
   17|       |
   18|      1|    func test_toDay() {
   19|      1|        let date = Amlich.toDate(jd: 2299160)
   20|      1|        XCTAssertEqual(date.day, 4)
   21|      1|        XCTAssertEqual(date.month, 10)
   22|      1|        XCTAssertEqual(date.year, 1582)
   23|      1|    }
   24|       |
   25|      1|    func test_newMoon() {
   26|      1|        XCTAssertEqual(Amlich.newMoon(of: 10), 2415316.060423006)
   27|      1|    }
   28|       |
   29|      1|    func test_sunLongitude() {
   30|      1|        XCTAssertEqual(Amlich.sunLongitude(of: 10), 4.45054572657682)
   31|      1|        XCTAssertEqual(Amlich.sunLongitude(of: 10, with: 7), 8)
   32|      1|    }
   33|       |
   34|      1|    func test_sunLongitudeAsAngle() {
   35|      1|        XCTAssertEqual(Amlich.sunLongitudeAsAngle(of: 2459080.2083333335), 146.19908004776426)
   36|      1|    }
   37|       |
   38|      1|    func test_newMoonDay() {
   39|      1|        XCTAssertEqual(Amlich.newMoonDay(of: 10, with: 7), 2415316)
   40|      1|    }
   41|       |    
   42|      1|    func test_lunarMonth11() {
   43|      1|        XCTAssertEqual(Amlich.lunarMonth11(of: 2020, with: 7), 2459198)
   44|      1|    }
   45|       |
   46|      1|    func test_leapMonthOffset() {
   47|      1|        XCTAssertEqual(Amlich.leapMonthOffset(of: 100, with: 7), 10)
   48|      1|    }
   49|       |    
   50|      1|    func test_toLunar() {
   51|      1|        let solarDate = SolarDate(day: 18, month: 8, year: 2020)
   52|      1|        let lunarDate = Amlich.toLunar(of: solarDate, with: +7)
   53|      1|
   54|      1|        XCTAssertEqual(lunarDate.day, 29)
   55|      1|        XCTAssertEqual(lunarDate.month, 6)
   56|      1|        XCTAssertEqual(lunarDate.year, 2020)
   57|      1|        XCTAssertEqual(lunarDate.isLeap, false)
   58|      1|        
   59|      1|        let anotherSolarDate = SolarDate(day: 18, month: 8, year: 2025)
   60|      1|        let anotherLunarDate = Amlich.toLunar(of: anotherSolarDate, with: +7)
   61|      1|        
   62|      1|        XCTAssertEqual(anotherLunarDate.day, 25)
   63|      1|        XCTAssertEqual(anotherLunarDate.month, 6)
   64|      1|        XCTAssertEqual(anotherLunarDate.year, 2025)
   65|      1|        XCTAssertEqual(anotherLunarDate.isLeap, true)
   66|      1|
   67|      1|    }
   68|       |    
   69|      1|    func test_toSolar() {
   70|      1|        let lunarDate = LunarDate(day: 29, month: 6, year: 2020, isLeap: false)
   71|      1|        let solarDate = Amlich.toSolar(of: lunarDate, with: +7)
   72|      1|
   73|      1|        XCTAssertEqual(solarDate.day, 18)
   74|      1|        XCTAssertEqual(solarDate.month, 8)
   75|      1|        XCTAssertEqual(solarDate.year, 2020)
   76|      1|    }
   77|       |}

/Volumes/WIP/Amlich/Tests/AmlichTests/LunarDateTestCase.swift:
    1|       |//
    2|       |//  LunarDateTestCase.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/18/20.
    6|       |//
    7|       |
    8|       |import XCTest
    9|       |@testable import Amlich
   10|       |
   11|       |final class LunarDateTestCase: XCTestCase {
   12|      1|    func test_of() {
   13|      1|        let solarDate = SolarDate(day: 18, month: 8, year: 2020)
   14|      1|        let hanoiTimeZone: Double = +7
   15|      1|        let lunarDate = LunarDate.of(solar: solarDate, with: hanoiTimeZone)
   16|      1|                
   17|      1|        XCTAssertEqual(lunarDate.day, 29)
   18|      1|        XCTAssertEqual(lunarDate.month, 6)
   19|      1|        XCTAssertEqual(lunarDate.year, 2020)
   20|      1|        XCTAssertFalse(lunarDate.isLeap)
   21|      1|    }
   22|       |
   23|      1|    func test_fromDateObject() {
   24|      1|        let formatter = DateFormatter()
   25|      1|
   26|      1|        formatter.dateFormat = "yyyy MM dd"
   27|      1|        let date = formatter.date(from: "2020 8 21")!
   28|      1|
   29|      1|        let lunarDate = LunarDate.from(date)
   30|      1|
   31|      1|        XCTAssertEqual(lunarDate.day, 21)
   32|      1|        XCTAssertEqual(lunarDate.month, 8)
   33|      1|        XCTAssertEqual(lunarDate.year, 2020)
   34|      1|    }
   35|       |
   36|      1|    func test_ofDateObject() {
   37|      1|        let formatter = DateFormatter()
   38|      1|
   39|      1|        formatter.dateFormat = "yyyy MM dd"
   40|      1|        let date = formatter.date(from: "2020 8 21")!
   41|      1|
   42|      1|        let lunarDate = LunarDate.of(date, with: 7.0)
   43|      1|
   44|      1|        XCTAssertEqual(lunarDate.day, 3)
   45|      1|        XCTAssertEqual(lunarDate.month, 7)
   46|      1|        XCTAssertEqual(lunarDate.year, 2020)
   47|      1|    }
   48|       |
   49|      1|    func test_toDate() {
   50|      1|        let lunarDate = LunarDate(day: 1, month: 6, year: 2020, isLeap: false)
   51|      1|
   52|      1|        let dateFormatter = DateFormatter()
   53|      1|        dateFormatter.dateFormat = "dd MM yyyy"
   54|      1|
   55|      1|        let expectedDate = dateFormatter.date(from: "1 6 2020")!
   56|      1|
   57|      1|        let date = lunarDate.toDate()!
   58|      1|        XCTAssertTrue(date.compare(expectedDate) == .orderedSame)
   59|      1|
   60|      1|        let invalidLunarDate = LunarDate(day: 0, month: 0, year: 0, isLeap: false)
   61|      1|        XCTAssertNil(invalidLunarDate.toDate())
   62|      1|    }
   63|       |
   64|      1|    func test_toSonar() {
   65|      1|        let lunarDate = LunarDate(day: 29, month: 6, year: 2020, isLeap: false)
   66|      1|        let hanoiTimeZone = +7.0
   67|      1|        let solarDate = lunarDate.toSolar(with: hanoiTimeZone);
   68|      1|        
   69|      1|        XCTAssertEqual(solarDate.day, 18)
   70|      1|        XCTAssertEqual(solarDate.month, 8)
   71|      1|        XCTAssertEqual(solarDate.year, 2020)
   72|      1|    }
   73|       |    
   74|      1|    func test_comparable() {
   75|      1|        let lunarDate1 = LunarDate(day: 10, month: 10, year: 2020, isLeap: false)
   76|      1|        let lunarDate2 = LunarDate(day: 11, month: 10, year: 2020, isLeap: false)
   77|      1|        
   78|      1|        XCTAssertTrue(lunarDate1 < lunarDate2)
   79|      1|        XCTAssertTrue(lunarDate1 <= lunarDate2)
   80|      1|        XCTAssertTrue(lunarDate2 > lunarDate1)
   81|      1|        XCTAssertTrue(lunarDate2 >= lunarDate1)
   82|      1|
   83|      1|        XCTAssertFalse(lunarDate2 == lunarDate1)
   84|      1|    }
   85|       |
   86|      1|    func test_equalable() {
   87|      1|        let lunarDate1 = LunarDate(day: 10, month: 10, year: 2020, isLeap: false)
   88|      1|        let lunarDate2 = LunarDate(day: 10, month: 10, year: 2020, isLeap: false)
   89|      1|        
   90|      1|        XCTAssertFalse(lunarDate1 < lunarDate2)
   91|      1|        XCTAssertFalse(lunarDate2 > lunarDate1)
   92|      1|
   93|      1|        XCTAssertTrue(lunarDate1 <= lunarDate2)
   94|      1|        XCTAssertTrue(lunarDate2 >= lunarDate1)
   95|      1|        XCTAssertTrue(lunarDate2 == lunarDate1)
   96|      1|        
   97|      1|        let lunarDate3 = LunarDate(day: 10, month: 10, year: 2020, isLeap: false)
   98|      1|        let lunarDate4 = LunarDate(day: 10, month: 10, year: 2020, isLeap: true)
   99|      1|
  100|      1|        XCTAssertFalse(lunarDate3 == lunarDate4)
  101|      1|    }
  102|       |}

/Volumes/WIP/Amlich/Tests/AmlichTests/SolarDateTestCase.swift:
    1|       |//
    2|       |//  SolarDateTestCase.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/18/20.
    6|       |//
    7|       |
    8|       |import XCTest
    9|       |@testable import Amlich
   10|       |
   11|       |final class SolarDateTestCase: XCTestCase {
   12|      1|    func test_of() {
   13|      1|        let lunarDate = LunarDate(day: 29, month: 6, year: 2020, isLeap: false)
   14|      1|        let hanoiTimeZone: Double = +7
   15|      1|        let solarDate = SolarDate.of(lunar: lunarDate, with: hanoiTimeZone)
   16|      1|
   17|      1|        XCTAssertEqual(solarDate.day, 18)
   18|      1|        XCTAssertEqual(solarDate.month, 8)
   19|      1|        XCTAssertEqual(solarDate.year, 2020)
   20|      1|    }
   21|       |
   22|      1|    func test_fromDateObject() {
   23|      1|        let formatter = DateFormatter()
   24|      1|
   25|      1|        formatter.dateFormat = "yyyy MM dd"
   26|      1|        let date = formatter.date(from: "2020 8 21")!
   27|      1|
   28|      1|        let solarDate = SolarDate.from(date)
   29|      1|
   30|      1|        XCTAssertEqual(solarDate.day, 21)
   31|      1|        XCTAssertEqual(solarDate.month, 8)
   32|      1|        XCTAssertEqual(solarDate.year, 2020)
   33|      1|    }
   34|       |
   35|      1|    func test_ofDateObject() {
   36|      1|        let formatter = DateFormatter()
   37|      1|
   38|      1|        formatter.dateFormat = "yyyy MM dd"
   39|      1|        let date = formatter.date(from: "2020 7 3")!
   40|      1|
   41|      1|        let solarDate = SolarDate.of(date, with: 7)
   42|      1|
   43|      1|        XCTAssertEqual(solarDate.day, 21)
   44|      1|        XCTAssertEqual(solarDate.month, 8)
   45|      1|        XCTAssertEqual(solarDate.year, 2020)
   46|      1|    }
   47|       |
   48|      1|    func test_toLunar() {
   49|      1|        let solarDate = SolarDate(day: 18, month: 8, year: 2020)
   50|      1|        let hanoiTimeZone = +7.0
   51|      1|        let lunarDate = solarDate.toLunar(with: hanoiTimeZone);
   52|      1|        
   53|      1|        XCTAssertEqual(lunarDate.day, 29)
   54|      1|        XCTAssertEqual(lunarDate.month, 6)
   55|      1|        XCTAssertEqual(lunarDate.year, 2020)
   56|      1|    }
   57|       |
   58|      1|    func test_toDate() {
   59|      1|        let solarDate = SolarDate(day: 1, month: 6, year: 2020)
   60|      1|
   61|      1|        let dateFormatter = DateFormatter()
   62|      1|        dateFormatter.dateFormat = "dd MM yyyy"
   63|      1|
   64|      1|        let expectedDate = dateFormatter.date(from: "1 6 2020")!
   65|      1|
   66|      1|        let date = solarDate.toDate()!
   67|      1|        XCTAssertTrue(date.compare(expectedDate) == .orderedSame)
   68|      1|
   69|      1|        let invalidSolarDate = SolarDate(day: 0, month: 0, year: 0)
   70|      1|        XCTAssertNil(invalidSolarDate.toDate())
   71|      1|    }
   72|       |
   73|      1|    func test_comparable() {
   74|      1|        let solarDate1 = SolarDate(day: 10, month: 10, year: 2020)
   75|      1|        let solarDate2 = SolarDate(day: 11, month: 10, year: 2020)
   76|      1|        
   77|      1|        XCTAssertTrue(solarDate1 < solarDate2)
   78|      1|        XCTAssertTrue(solarDate1 <= solarDate2)
   79|      1|        XCTAssertTrue(solarDate2 > solarDate1)
   80|      1|        XCTAssertTrue(solarDate2 >= solarDate1)
   81|      1|
   82|      1|        XCTAssertFalse(solarDate2 == solarDate1)
   83|      1|    }
   84|       |
   85|      1|    func test_equalable() {
   86|      1|        let solarDate1 = SolarDate(day: 10, month: 10, year: 2020)
   87|      1|        let solarDate2 = SolarDate(day: 10, month: 10, year: 2020)
   88|      1|        
   89|      1|        XCTAssertFalse(solarDate1 < solarDate2)
   90|      1|        XCTAssertFalse(solarDate2 > solarDate1)
   91|      1|
   92|      1|        XCTAssertTrue(solarDate1 <= solarDate2)
   93|      1|        XCTAssertTrue(solarDate2 >= solarDate1)
   94|      1|        XCTAssertTrue(solarDate2 == solarDate1)
   95|      1|    }
   96|       |}

/Volumes/WIP/Amlich/Tests/AmlichTests/SolarTermTestCase.swift:
    1|       |//
    2|       |//  File.swift
    3|       |//  
    4|       |//
    5|       |//  Created by Mac Van Anh on 8/19/20.
    6|       |//
    7|       |
    8|       |import XCTest
    9|       |@testable import Amlich
   10|       |
   11|       |final class SolarTermTestCase: XCTestCase {
   12|      1|    func test_totalTerms() {
   13|      1|        XCTAssertEqual(SolarTerm.allCases.count, 24)
   14|      1|    }
   15|       |
   16|      1|    func test_of() {
   17|      1|        let solarDate = SolarDate(day: 19, month: 8, year: 2020)
   18|      1|        let hour = (hh: 0, mm: 0)
   19|      1|
   20|      1|        XCTAssertEqual(SolarTerm.of(solar: solarDate, in: hour, with: 7), SolarTerm.summerSolstice)
   21|      1|    }
   22|       |}

